"""
Mode Monitoring API - Backend monitoring for the mode subsystem

GET /api/mode/alerts - Get recent alerts with optional filtering
GET /api/mode/stats - Get alert statistics
POST /api/mode/alerts/clear - Clear recent alerts buffer

This API provides observability for the mode policy enforcement system,
exposing alerts and statistics from the ModeAlertAggregator.

Phase 3.1 Implementation - Task #12
"""

from fastapi import APIRouter, Query, HTTPException
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
from datetime import datetime, timezone
import logging

from agentos.core.mode.mode_alerts import (
    get_alert_aggregator,
    ModeAlert,
    AlertSeverity
)

logger = logging.getLogger(__name__)

router = APIRouter()


class AlertResponse(BaseModel):
    """Single alert response model"""
    timestamp: str
    severity: str
    mode_id: str
    operation: str
    message: str
    context: Dict[str, Any] = Field(default_factory=dict)


class AlertsResponse(BaseModel):
    """Response model for GET /api/mode/alerts"""
    status: str = "ok"
    alerts: List[AlertResponse]
    stats: Dict[str, Any]


class StatsResponse(BaseModel):
    """Response model for GET /api/mode/stats"""
    status: str = "ok"
    stats: Dict[str, Any]


class ClearResponse(BaseModel):
    """Response model for POST /api/mode/alerts/clear"""
    status: str = "ok"
    message: str
    cleared_count: int


@router.get("/alerts", response_model=AlertsResponse)
async def get_alerts(
    severity: Optional[str] = Query(
        None,
        description="Filter by severity level (info, warning, error, critical)",
        pattern="^(info|warning|error|critical)$"
    ),
    limit: Optional[int] = Query(
        50,
        ge=1,
        le=1000,
        description="Maximum number of alerts to return (1-1000, default: 50)"
    )
) -> AlertsResponse:
    """
    Get recent alerts from the mode subsystem

    This endpoint returns alerts generated by the mode policy enforcement system,
    including violations, warnings, and informational messages.

    Query Parameters:
        severity: Optional filter by severity level (info, warning, error, critical)
        limit: Maximum number of alerts to return (default: 50, max: 1000)

    Returns:
        AlertsResponse containing:
        - status: "ok" or "error"
        - alerts: List of recent alerts (newest last)
        - stats: Aggregate statistics

    Example:
        GET /api/mode/alerts?severity=error&limit=20

    Response:
        {
            "status": "ok",
            "alerts": [
                {
                    "timestamp": "2026-01-30T12:00:00Z",
                    "severity": "error",
                    "mode_id": "design",
                    "operation": "apply_diff",
                    "message": "Mode 'design' attempted to apply diff (forbidden)",
                    "context": {
                        "audit_context": "exec_001",
                        "allows_commit": false
                    }
                }
            ],
            "stats": {
                "total_alerts": 150,
                "recent_count": 50,
                "severity_breakdown": {
                    "error": 30,
                    "warning": 15,
                    "info": 5
                },
                "max_recent": 100,
                "output_count": 1
            }
        }
    """
    try:
        # Get the global alert aggregator
        aggregator = get_alert_aggregator()

        # Get recent alerts
        recent_alerts = aggregator.get_recent_alerts(limit=None)

        # Apply severity filter if specified
        if severity:
            severity_enum = AlertSeverity(severity)
            recent_alerts = [
                alert for alert in recent_alerts
                if alert.severity == severity_enum
            ]

        # Apply limit (get last N alerts - most recent)
        if limit and len(recent_alerts) > limit:
            recent_alerts = recent_alerts[-limit:]

        # Convert to response format
        alert_responses = [
            AlertResponse(**alert.to_dict())
            for alert in recent_alerts
        ]

        # Get statistics
        stats = aggregator.get_stats()

        return AlertsResponse(
            status="ok",
            alerts=alert_responses,
            stats=stats
        )

    except ValueError as e:
        # Invalid severity value
        logger.warning(f"Invalid severity filter: {severity}")
        raise HTTPException(
            status_code=400,
            detail={
                "ok": False,
                "error": "invalid_severity",
                "message": f"Invalid severity level: {severity}",
                "valid_values": ["info", "warning", "error", "critical"]
            }
        )
    except Exception as e:
        logger.error(f"Failed to retrieve mode alerts: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail={
                "ok": False,
                "error": "internal_error",
                "message": "Failed to retrieve mode alerts",
                "details": str(e)
            }
        )


@router.get("/stats", response_model=StatsResponse)
async def get_stats() -> StatsResponse:
    """
    Get mode alert statistics

    Returns aggregate statistics about the mode subsystem alerts,
    including total counts, severity breakdown, and system information.

    Returns:
        StatsResponse containing:
        - status: "ok" or "error"
        - stats: Statistics dictionary with:
            - total_alerts: Total number of alerts generated since startup
            - recent_count: Number of alerts currently in buffer
            - severity_breakdown: Count by severity level (info, warning, error, critical)
            - max_recent: Maximum buffer size
            - output_count: Number of registered output channels

    Example:
        GET /api/mode/stats

    Response:
        {
            "status": "ok",
            "stats": {
                "total_alerts": 150,
                "recent_count": 100,
                "severity_breakdown": {
                    "info": 10,
                    "warning": 30,
                    "error": 60,
                    "critical": 0
                },
                "max_recent": 100,
                "output_count": 2
            }
        }
    """
    try:
        # Get the global alert aggregator
        aggregator = get_alert_aggregator()

        # Get statistics
        stats = aggregator.get_stats()

        return StatsResponse(
            status="ok",
            stats=stats
        )

    except Exception as e:
        logger.error(f"Failed to retrieve mode stats: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail={
                "ok": False,
                "error": "internal_error",
                "message": "Failed to retrieve mode statistics",
                "details": str(e)
            }
        )


@router.post("/alerts/clear", response_model=ClearResponse)
async def clear_alerts() -> ClearResponse:
    """
    Clear the recent alerts buffer

    This endpoint clears the in-memory alert buffer (does not affect total count).
    Useful for resetting the alert view after acknowledging issues.

    Note: This only clears the buffer maintained by the aggregator.
    Alerts written to file or webhook outputs are not affected.

    Returns:
        ClearResponse containing:
        - status: "ok" or "error"
        - message: Confirmation message
        - cleared_count: Number of alerts that were cleared

    Example:
        POST /api/mode/alerts/clear

    Response:
        {
            "status": "ok",
            "message": "Successfully cleared 50 alerts from buffer",
            "cleared_count": 50
        }
    """
    try:
        # Get the global alert aggregator
        aggregator = get_alert_aggregator()

        # Get count before clearing
        cleared_count = len(aggregator.recent_alerts)

        # Clear the buffer
        aggregator.clear_recent()

        return ClearResponse(
            status="ok",
            message=f"Successfully cleared {cleared_count} alerts from buffer",
            cleared_count=cleared_count
        )

    except Exception as e:
        logger.error(f"Failed to clear mode alerts: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail={
                "ok": False,
                "error": "internal_error",
                "message": "Failed to clear mode alerts",
                "details": str(e)
            }
        )


def register_routes(app):
    """
    Register mode monitoring routes to FastAPI app

    This function is provided for compatibility with the task specification,
    but in this codebase, routes are registered using app.include_router()
    in agentos/webui/app.py instead.

    Args:
        app: FastAPI application instance

    Example:
        from agentos.webui.api import mode_monitoring
        mode_monitoring.register_routes(app)

    Recommended approach (in app.py):
        from agentos.webui.api import mode_monitoring
        app.include_router(mode_monitoring.router, prefix="/api/mode", tags=["mode"])
    """
    app.include_router(router, prefix="/api/mode", tags=["mode"])


# Export router for app.py registration
__all__ = [
    "router",
    "register_routes",
    "AlertResponse",
    "AlertsResponse",
    "StatsResponse",
    "ClearResponse",
]
