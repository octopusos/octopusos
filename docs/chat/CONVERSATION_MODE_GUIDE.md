# Conversation Mode 用户指南

## 什么是 Conversation Mode

Conversation Mode(对话模式)定义了 AgentOS 与您交互的方式和风格。它控制对话的**语气、详细程度和输出格式**,但不影响系统的安全权限。

AgentOS 提供 5 种对话模式,每种模式针对不同的使用场景进行了优化:

```
chat        → 日常对话助手(友好、解释性强)
discussion  → 深度分析讨论(多角度、结构化推理)
plan        → 战略规划模式(高层次、步骤分解)
development → 开发实现模式(代码为中心、技术细节)
task        → 目标执行模式(简洁、直接行动)
```

**核心原则**: 对话模式只影响**交互体验**,不影响**安全权限**。权限由 Execution Phase(执行阶段)独立控制。

---

## 5 种模式详解

### 1. chat 模式 - 日常对话助手

**适用场景**:
- 一般性问题咨询
- 学习新知识
- 探索最佳实践
- 需要详细解释

**特点**:
- 友好、对话式语气
- 详细解释推理过程
- 主动提问以明确需求
- 提供代码示例(Markdown 格式)

**示例对话**:

```
用户: 如何实现缓存?

助手(chat 模式):
有几种常见的缓存实现方式,我来为您介绍:

1. **内存缓存**(如 Python 的 lru_cache)
   - 优点:速度极快,实现简单
   - 缺点:进程重启后丢失

2. **Redis 缓存**
   - 优点:跨进程共享,持久化
   - 缺点:需要额外服务

3. **文件缓存**
   - 优点:简单,无需外部依赖
   - 缺点:I/O 开销大

请问您的应用规模如何?是单进程还是分布式?这样我可以给出更具体的建议。

如果需要我帮您实现,可以输入 /execute 切换到执行阶段。
```

---

### 2. discussion 模式 - 深度分析讨论

**适用场景**:
- 架构决策讨论
- 技术选型分析
- 权衡利弊评估
- 探索多种方案

**特点**:
- 分析性、多角度视角
- 系统化探讨权衡
- 苏格拉底式提问
- 结构化推理(pros/cons 列表)

**示例对话**:

```
用户: 我们应该用微服务还是单体架构?

助手(discussion 模式):
这是一个关键的架构决策,让我们系统地分析:

**微服务架构**
优点:
- 独立部署,降低发布风险
- 技术栈灵活,团队自主性高
- 可针对性能瓶颈进行局部扩展

缺点:
- 运维复杂度显著提升
- 分布式事务处理困难
- 调试和监控成本增加

**单体架构**
优点:
- 开发简单,调试直观
- 部署简单,易于监控
- 性能开销低(无网络调用)

缺点:
- 代码耦合度高,修改风险大
- 扩展性受限,必须整体扩展
- 大型团队协作困难

**关键问题**:
1. 您的团队规模是多少?(< 10 人建议单体)
2. 预期用户规模?(< 10万 用户单体通常足够)
3. 是否有复杂的业务领域边界?(有则倾向微服务)
4. 团队的 DevOps 能力如何?(微服务需要强 DevOps)

基于这些因素,我们可以做出更明智的选择。
```

---

### 3. plan 模式 - 战略规划模式

**适用场景**:
- 项目规划
- 迁移计划
- 架构设计
- 风险评估

**特点**:
- 高层次视角
- 分步骤规划
- 资源估算
- 风险识别
- 不生成代码(按惯例)

**示例对话**:

```
用户: 规划迁移到 AgentOS 2.0

助手(plan 模式):
# AgentOS 2.0 迁移计划

## 阶段 1: 评估与准备(第 1-2 周)
**目标**: 理解现有系统,识别迁移风险
- [ ] 审计当前代码库依赖关系
- [ ] 识别 API 兼容性变更
- [ ] 评估自定义扩展迁移成本
- [ ] 建立测试环境

**资源需求**: 2 名工程师,1 个测试环境
**风险**: 依赖冲突,API 不兼容

## 阶段 2: 增量迁移(第 3-6 周)
**目标**: 逐步迁移核心模块
- [ ] 迁移任务管理模块
- [ ] 迁移通信适配器
- [ ] 迁移扩展系统
- [ ] 回归测试每个模块

**资源需求**: 3 名工程师,持续集成环境
**风险**: 数据迁移失败,功能回退

## 阶段 3: 验证与切换(第 7-8 周)
**目标**: 全面测试,生产环境切换
- [ ] 端到端测试
- [ ] 性能基准测试
- [ ] 金丝雀发布(5% 流量)
- [ ] 全量切换

**资源需求**: 全团队参与,生产环境访问权限
**风险**: 生产事故,用户体验下降

## 关键里程碑
- Week 2: 迁移计划审批通过
- Week 4: 50% 功能迁移完成
- Week 6: 100% 功能迁移,测试通过
- Week 8: 生产环境全量上线

## 应急方案
如果出现严重问题:
1. 立即回滚到 1.x 版本
2. 保留 1.x 环境 2 周作为备份
3. 建立问题升级机制
```

---

### 4. development 模式 - 开发实现模式

**适用场景**:
- 编写代码
- 实现功能
- 代码重构
- 技术实现

**特点**:
- 以代码为中心
- 技术细节丰富
- 实现建议
- 最佳实践
- 简洁的技术解释

**示例对话**:

```
用户: 实现新的缓存层

助手(development 模式):
建议使用 Redis + LRU 内存缓存的两层缓存架构。

实现代码:

# cache.py
from functools import lru_cache
import redis
from typing import Optional

class TwoTierCache:
    def __init__(self, redis_url: str):
        self.redis = redis.from_url(redis_url)
        self._local_cache_size = 100

    @lru_cache(maxsize=100)
    def _get_from_local(self, key: str) -> Optional[str]:
        """L1: 本地内存缓存(最快)"""
        return self.redis.get(key)

    def get(self, key: str) -> Optional[str]:
        """获取缓存值"""
        # L1: 尝试本地缓存
        value = self._get_from_local(key)
        if value:
            return value

        # L2: Redis 缓存
        value = self.redis.get(key)
        if value:
            # 回填 L1 缓存
            self._get_from_local.cache_info()
        return value

    def set(self, key: str, value: str, ttl: int = 3600):
        """设置缓存"""
        self.redis.setex(key, ttl, value)
        # 清除本地缓存以保持一致性
        self._get_from_local.cache_clear()

技术要点:
- L1 缓存(lru_cache)避免频繁 Redis 查询
- TTL 防止数据过期
- 写入时清除 L1 保证一致性

需要我创建测试用例吗?输入 /execute 进入执行阶段。
```

**注意**: development 模式会建议切换到 execution 阶段,但需要您明确批准 `/execute`。

---

### 5. task 模式 - 目标执行模式

**适用场景**:
- 明确的任务执行
- 快速修复
- 简洁的结果报告
- 自动化工作流

**特点**:
- 最少解释
- 直接行动
- 进度报告
- 结果导向
- 无冗余讨论

**示例对话**:

```
用户: 修复 test_auth.py 中失败的测试

助手(task 模式):
正在修复...

已完成:
✅ 修复 test_login_invalid_credentials (修正断言逻辑)
✅ 修复 test_token_expiry (更新时间常量)
✅ 修复 test_refresh_token (添加 missing mock)

结果: 3/3 测试通过

运行: pytest test_auth.py
输出:
===== 3 passed in 1.23s =====

完成。
```

**注意**: task 模式极度简洁,适合您已明确知道要做什么的场景。

---

## 如何切换对话模式

### 方法 1: 使用 /mode 命令(WebUI 和 CLI)

```bash
/mode chat         # 切换到 chat 模式
/mode discussion   # 切换到 discussion 模式
/mode plan         # 切换到 plan 模式
/mode development  # 切换到 development 模式
/mode task         # 切换到 task 模式
```

### 方法 2: 在 WebUI 中使用模式选择器

1. 在聊天界面顶部找到"对话模式"下拉菜单
2. 点击选择您需要的模式
3. 模式会立即切换,无需刷新页面

**当前模式指示器**:
```
┌─────────────────────────────────────┐
│ 对话模式: development | 执行阶段: planning │
└─────────────────────────────────────┘
```

### 方法 3: 自动建议(系统提示)

当系统检测到您的需求可能适合其他模式时,会显示建议:

```
💡 提示: 您似乎在规划项目架构。
建议切换到 'plan' 模式以获得更好的规划体验。
输入 /mode plan 切换。
```

---

## 执行阶段(Execution Phase)说明

**重要**: 对话模式只影响交互体验,不影响安全权限。权限由执行阶段独立控制。

### 两个执行阶段

#### 1. planning 阶段(规划阶段,默认)

**允许的操作**:
- 读取文件
- 列出目录
- Web 搜索(`/comm search`)
- Web 抓取(`/comm fetch`)
- 分析代码

**禁止的操作**:
- 执行 Bash 命令
- 修改文件
- 安装扩展
- 执行外部程序

**适用场景**: 探索、学习、规划、分析

#### 2. execution 阶段(执行阶段)

**允许的操作**:
- 所有 planning 阶段的操作
- 执行 Bash 命令
- 创建/修改/删除文件
- 安装和执行扩展
- 所有系统操作

**适用场景**: 实现、修改、部署、自动化

### 如何切换执行阶段

```bash
# 切换到 execution 阶段(需要明确批准)
/execute

# 切换回 planning 阶段
/plan
```

**安全保证**: 无论您使用哪种对话模式,系统都会在 planning 阶段阻止危险操作。

**示例**:
```
当前: development 模式 + planning 阶段

用户: 创建 cache.py 文件

助手: ❌ 错误: 无法在 planning 阶段创建文件
      请输入 /execute 切换到 execution 阶段

用户: /execute

助手: ✅ 已切换到 execution 阶段
      现在可以创建文件...
```

---

## 模式与阶段的关系

### 关键区别

| 维度 | 对话模式(Mode) | 执行阶段(Phase) |
|------|---------------|----------------|
| **控制内容** | 如何交互 | 能做什么 |
| **影响范围** | 语气、格式、详细度 | 安全权限、功能访问 |
| **切换方式** | 自由切换 | 需要明确批准 |
| **示例** | chat, discussion, plan | planning, execution |

### 最佳实践组合

| 场景 | 推荐模式 | 推荐阶段 |
|------|---------|---------|
| 学习新技术 | chat | planning |
| 架构讨论 | discussion | planning |
| 项目规划 | plan | planning |
| 编写代码 | development | execution |
| 执行任务 | task | execution |
| 探索代码库 | chat | planning |
| 重构代码 | development | execution |

**提示**: 系统会根据您的模式选择建议最佳阶段,但最终决定权在您手中。

---

## 常见问题解答(FAQ)

### Q1: 对话模式会影响安全权限吗?

**不会。** 对话模式只控制交互方式,不影响权限。无论您选择哪种模式,安全权限都由执行阶段独立控制。

例如: development 模式 + planning 阶段 = 代码风格的对话,但无法执行危险操作。

---

### Q2: 切换模式需要批准吗?

**不需要。** 模式切换是 UX 层面的变化,可以随时自由切换。

只有执行阶段切换(`/execute`, `/plan`)才需要明确批准。

---

### Q3: development 模式会自动进入 execution 阶段吗?

**不会。** development 模式会建议您切换到 execution 阶段以获得最佳体验,但不会自动切换。

您必须明确输入 `/execute` 才会切换阶段。

---

### Q4: 可以在一个对话中混用多种模式吗?

**可以。** 您可以随时切换模式,系统会保留对话历史。

例如:
1. 用 discussion 模式讨论架构
2. 切换到 plan 模式制定实施计划
3. 切换到 development 模式开始编码

---

### Q5: task 模式会跳过安全检查吗?

**不会。** task 模式只是简化了输出格式,所有安全检查依然有效。

如果您在 planning 阶段使用 task 模式,依然无法执行危险操作。

---

### Q6: 如何知道当前处于哪个模式和阶段?

WebUI 会在聊天界面顶部显示:

```
┌─────────────────────────────────────┐
│ 对话模式: development | 执行阶段: execution │
└─────────────────────────────────────┘
```

CLI 会在提示符中显示:

```
AgentOS [development|execution] >
```

---

### Q7: 系统如何建议模式切换?

系统会根据您的输入内容智能建议:

- 检测到"规划"、"计划"等关键词 → 建议 plan 模式
- 检测到"实现"、"编码"等关键词 → 建议 development 模式
- 检测到"修复"、"执行"等关键词 → 建议 task 模式

建议仅供参考,最终决定权在您。

---

### Q8: 可以为不同项目设置默认模式吗?

**可以(未来功能)。** 当前版本默认为 chat 模式,未来版本将支持:

- 项目级默认模式配置
- 用户级偏好设置
- 根据任务类型自动选择模式

---

### Q9: 扩展可以定义自定义模式吗?

**可以(未来功能)。** 当前版本支持 5 种内置模式,未来将开放扩展 API 允许自定义模式。

---

### Q10: 模式切换会中断当前任务吗?

**不会。** 模式切换只影响输出格式,不影响任务执行。

任务会保持在当前状态,只是后续的交互风格会改变。

---

## 使用建议

### 新手用户

**推荐**: 从 `chat` 模式开始
- 友好的交互体验
- 详细的解释
- 适合学习和探索

### 架构师/技术负责人

**推荐**: `discussion` 模式用于决策,`plan` 模式用于规划
- 深度分析
- 结构化思考
- 清晰的权衡分析

### 开发人员

**推荐**: `development` 模式(配合 `execution` 阶段)
- 代码为中心
- 快速实现
- 技术细节

### 运维/DevOps

**推荐**: `task` 模式(配合 `execution` 阶段)
- 简洁高效
- 快速执行
- 结果导向

---

## 安全提醒

1. **模式不等于权限**: 不要因为切换到 development 模式就认为可以执行危险操作。
2. **始终确认阶段**: 在执行危险操作前,确认您处于 execution 阶段。
3. **审查建议操作**: 即使在 execution 阶段,也要审查系统建议的操作。
4. **理解阶段转换**: `/execute` 命令会赋予系统更高权限,请谨慎使用。

---

## 相关文档

- [Mode vs Phase 概念对比](./MODE_VS_PHASE.md)
- [ADR-CHAT-MODE-001: Conversation Mode 架构](../adr/ADR-CHAT-MODE-001-Conversation-Mode-Architecture.md)
- [Communication Adapter 文档](./COMMUNICATION_ADAPTER.md)
- [快速参考卡片](./CONVERSATION_MODE_QUICK_REF.md)

---

**享受更灵活、更安全的 AgentOS 对话体验!**
