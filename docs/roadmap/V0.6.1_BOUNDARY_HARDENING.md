# v0.6.1 Boundary Hardening - System-Level Enforcement

**Epic ID**: v0.6.1
**Version**: v0.6.1
**Date Created**: 2026-01-30
**Status**: ⏳ PLANNED
**Priority**: HIGH
**Target Release**: TBD (Post v0.6.0 production validation)

---

## Epic Summary

**Title**: v0.6.1 Boundary Hardening - System-Level Enforcement

**Purpose**: Upgrade Execution Boundaries #2 (Planning Side-Effects) and #3 (Frozen Spec Validation) from convention-based enforcement to system-level enforcement with cryptographic guarantees.

**Background**: Penetration testing of v0.6.0 execution boundaries (Task #8) revealed **3 CRITICAL vulnerabilities** that allow bypasses of architectural guarantees:

- **B2-C1**: Planning guard is not automatically enforced - can be bypassed by not calling the guard
- **B3-C1**: Direct database modification bypasses spec_frozen validation
- **B3-C2**: No cryptographic verification that spec content is immutable

These vulnerabilities break the v0.6.0 architecture principles:
- "Planning = Zero Side Effects" is not enforced at runtime (convention only)
- "Execution Requires Frozen Spec" provides no cryptographic guarantee of immutability

**Scope**: This epic addresses **system-level enforcement** of boundaries, moving from "developer discipline" to "cannot be bypassed" guarantees.

---

## Strategic Context

### Why This Matters

**Boundary #2 (Planning Side-Effects)**:
- Current: Relies on developers calling `planning_guard.assert_operation_allowed()` before side effects
- Risk: Malicious or buggy code can bypass by simply not calling the guard
- Impact: Side effects can execute during planning phase, breaking reproducibility

**Boundary #3 (Frozen Spec)**:
- Current: `spec_frozen` is just a database flag with no content validation
- Risk: Database UPDATE can set flag without freezing, or modify content after freezing
- Impact: Execution uses unverified specifications, breaking auditability and reproducibility

### v0.6.0 → v0.6.1 Evolution

```
v0.6.0: Convention + Friction
├─ Planning guard: "Please call this API before side effects"
└─ Frozen spec: "Please set this flag to 1"

v0.6.1: System-Level Enforcement
├─ Planning guard: Import hooks intercept ALL side effects automatically
└─ Frozen spec: SHA-256 hash verifies content immutability cryptographically
```

---

## Sub-Tasks (Critical Vulnerabilities)

### Sub-task 1: B2-C1 - Planning Guard System-Level Enforcement

**Vulnerability ID**: B2-C1
**Vulnerability**: Planning guard not automatically enforced
**Severity**: CRITICAL
**Exploitability**: HIGH (requires only forgetting to call guard)

**Problem Statement**:
The `PlanningGuard` must be explicitly called by application code. Direct calls to `subprocess`, file I/O, or network APIs bypass the guard entirely. Python's dynamic nature means side effects are always available - the guard is a checking mechanism, not an enforcement mechanism.

**Current Architecture**:
```python
# ❌ CURRENT: Guard is optional
subprocess.run(["echo", "bypassed"])  # Executes without error
# Planning guard was never called, so it couldn't block
```

**Target Architecture**:
```python
# ✅ TARGET: Guard is automatic
subprocess.run(["echo", "blocked"])  # Raises PlanningSideEffectForbiddenError
# Import hooks intercept and check task context automatically
```

**Solution Approaches**:

#### Approach 1: Import Hooks (Recommended)
```python
import sys
from importlib.abc import MetaPathFinder, Loader

class SideEffectGuardHook(MetaPathFinder, Loader):
    """Automatically wrap side effect functions with guard checks"""

    def find_module(self, fullname, path=None):
        if fullname in ['subprocess', 'os', 'socket']:
            return self

    def load_module(self, fullname):
        # Wrap subprocess.run with automatic guard check
        original_module = __import__(fullname)

        if fullname == 'subprocess':
            original_run = original_module.run

            def guarded_run(*args, **kwargs):
                # Auto-inject planning guard check
                task_context = get_current_task_context()
                if task_context:
                    planning_guard.assert_operation_allowed(
                        "subprocess",
                        f"subprocess.run({args[0]})",
                        task_context
                    )
                return original_run(*args, **kwargs)

            original_module.run = guarded_run

        return original_module

# Install at startup
sys.meta_path.insert(0, SideEffectGuardHook())
```

**Advantages**:
- No code changes required for existing side-effect calls
- Works transparently across entire codebase
- Cannot be bypassed (hooks installed at import time)

**Disadvantages**:
- Performance overhead on every side-effect call
- Requires task context propagation mechanism
- Complex debugging if hooks misbehave

#### Approach 2: sys.settrace() Monitoring
```python
import sys

def trace_side_effects(frame, event, arg):
    """Trace execution and detect side effects during planning"""
    if event == 'call':
        func_name = frame.f_code.co_name
        module_name = frame.f_globals.get('__name__', '')

        # Detect side-effect calls
        if (module_name == 'subprocess' and func_name in ['run', 'Popen']) or \
           (module_name == 'os' and func_name in ['system', 'popen']) or \
           (func_name in ['write', 'open']):

            # Check if we're in planning phase
            task_context = get_current_task_context()
            if task_context and planning_guard.is_planning_phase(task_context.status):
                raise PlanningSideEffectForbiddenError(
                    f"Detected side effect during planning: {module_name}.{func_name}"
                )

sys.settrace(trace_side_effects)
```

**Advantages**:
- Catches all function calls, including monkeypatched ones
- No import hooks needed

**Disadvantages**:
- Significant performance overhead (traces every call)
- Complex to maintain
- May miss C-extension calls

#### Approach 3: OS-Level Sandbox (Long-term)
- Use Docker/containers with read-only filesystem
- Network disabled during planning phase
- No subprocess execution allowed
- Most secure but requires infrastructure changes

**Priority**: CRITICAL
**Target**: v0.6.1 Release Blocker

**Acceptance Criteria**:
- [ ] Import hooks intercept `subprocess.run()`, `os.system()`, `file.write()` automatically
- [ ] Task context automatically propagated to all threads/async contexts
- [ ] Side-effects blocked at runtime without requiring code changes
- [ ] Penetration test B2-C1 passes without code review dependency
- [ ] Performance overhead < 5% on planning operations
- [ ] Clear error messages identify blocked operation and task context
- [ ] Documentation updated with troubleshooting guide

**References**:
- **Vulnerability Report**: `BOUNDARY_PENETRATION_TEST_REPORT.md` (Lines 208-307, B2-C1)
- **Current Implementation**: `agentos/core/task/planning_guard.py`

**Estimated Effort**: 5-8 days
**Dependencies**: Task context propagation mechanism

---

### Sub-task 2: B3-C1 - Spec Hash Cryptographic Verification

**Vulnerability ID**: B3-C1
**Vulnerability**: Direct database modification bypasses validation
**Severity**: CRITICAL
**Exploitability**: HIGH (requires DB access)

**Problem Statement**:
`spec_frozen` can be set to 1 via direct SQL UPDATE without going through proper workflow validation. There is NO cryptographic verification that spec content is actually frozen. An attacker with database access can mark any spec as frozen without validation, or modify spec content after freezing.

**Current Schema**:
```sql
CREATE TABLE tasks (
    task_id TEXT PRIMARY KEY,
    spec_frozen INTEGER DEFAULT 0,
    metadata TEXT,  -- Contains spec content
    ...
);
-- ⚠️  No constraint linking spec_frozen to metadata immutability
-- ⚠️  No spec_hash column to verify content
```

**Target Schema**:
```sql
CREATE TABLE tasks (
    task_id TEXT PRIMARY KEY,
    spec_frozen INTEGER DEFAULT 0,
    spec_hash TEXT,  -- NEW: SHA-256 hash of frozen spec
    metadata TEXT,
    ...
);

-- Constraint: spec_frozen = 1 requires spec_hash
CREATE TRIGGER require_hash_when_frozen
BEFORE UPDATE OF spec_frozen ON tasks
FOR EACH ROW
WHEN NEW.spec_frozen = 1 AND NEW.spec_hash IS NULL
BEGIN
    SELECT RAISE(ABORT, 'Cannot set spec_frozen = 1 without spec_hash');
END;

-- Constraint: spec_hash prevents metadata modification
CREATE TRIGGER prevent_spec_modification_when_frozen
BEFORE UPDATE OF metadata ON tasks
FOR EACH ROW
WHEN NEW.spec_frozen = 1 AND NEW.metadata != OLD.metadata
BEGIN
    SELECT RAISE(ABORT, 'Cannot modify spec content when spec_frozen = 1');
END;
```

**Solution Implementation**:

#### Step 1: Add spec_hash Column
```sql
-- Migration: schema_v34_spec_hash.sql
ALTER TABLE tasks ADD COLUMN spec_hash TEXT;

-- Index for hash lookups
CREATE INDEX idx_tasks_spec_hash ON tasks(spec_hash);
```

#### Step 2: Compute Hash on Freeze
```python
import hashlib
import json

def freeze_spec(task_id: str, spec: dict) -> str:
    """Freeze spec and return cryptographic hash"""

    # Compute deterministic hash (canonical JSON)
    spec_json = json.dumps(spec, sort_keys=True, ensure_ascii=False)
    spec_hash = hashlib.sha256(spec_json.encode('utf-8')).hexdigest()

    # Store hash and set frozen flag atomically
    cursor.execute(
        """
        UPDATE tasks
        SET spec_frozen = 1, spec_hash = ?
        WHERE task_id = ?
        """,
        (spec_hash, task_id)
    )

    logger.info(f"Spec frozen for task {task_id}, hash: {spec_hash}")
    audit_log("spec_freeze", task_id=task_id, spec_hash=spec_hash)

    return spec_hash
```

#### Step 3: Verify Hash Before Execution
```python
def execute(self, execution_request):
    """Execute task with cryptographic spec verification"""
    task_id = execution_request.get("task_id")
    task = self.task_manager.get_task(task_id)

    # Boundary #3: Check spec_frozen flag
    if not task.is_spec_frozen():
        raise SpecNotFrozenError(
            task_id=task_id,
            spec_frozen=task.spec_frozen,
            message="Task specification is not frozen"
        )

    # NEW: Verify spec hash (cryptographic guarantee)
    if not task.spec_hash:
        raise SpecHashMissingError(
            task_id=task_id,
            message="Task is marked frozen but has no spec_hash"
        )

    # Recompute current spec hash
    current_spec = task.metadata.get("spec", {})
    current_spec_json = json.dumps(current_spec, sort_keys=True, ensure_ascii=False)
    current_hash = hashlib.sha256(current_spec_json.encode('utf-8')).hexdigest()

    # Compare hashes
    if current_hash != task.spec_hash:
        raise SpecModifiedAfterFreezeError(
            task_id=task_id,
            expected_hash=task.spec_hash,
            actual_hash=current_hash,
            message="Spec content does not match frozen hash - tampering detected"
        )

    # Proceed with execution (spec verified immutable)
    logger.info(f"Spec verification passed for task {task_id}, hash: {task.spec_hash}")
    ...
```

**Priority**: CRITICAL
**Target**: v0.6.1 Release Blocker

**Acceptance Criteria**:
- [ ] `spec_hash` column added to tasks table with migration
- [ ] SHA-256 hash computed on `freeze_spec()` and stored atomically with `spec_frozen = 1`
- [ ] Hash verified before execution in `ExecutorEngine.execute()`
- [ ] Content modification detected and execution blocked with `SpecModifiedAfterFreezeError`
- [ ] Database triggers prevent `spec_frozen = 1` without `spec_hash`
- [ ] Database triggers prevent metadata modification when `spec_frozen = 1`
- [ ] All spec-freezing code paths updated to use new API
- [ ] Penetration test B3-C1 passes
- [ ] Audit trail logs all hash computations and verifications

**References**:
- **Vulnerability Report**: `BOUNDARY_PENETRATION_TEST_REPORT.md` (Lines 455-579, B3-C1)
- **Current Implementation**: `agentos/core/executor/executor_engine.py` (Lines 388-395)
- **Database Schema**: `agentos/store/migrations/schema_v31_project_aware.sql`

**Estimated Effort**: 3-5 days
**Dependencies**: Database migration system

---

### Sub-task 3: B3-C2 - Prevent spec_frozen Tampering

**Vulnerability ID**: B3-C2
**Vulnerability**: No verification of spec content immutability
**Severity**: CRITICAL
**Exploitability**: HIGH (requires DB access)

**Problem Statement**:
This is the same vulnerability as B3-C1, stated differently. The `spec_frozen` flag does not enforce that spec content is immutable. There is no hash, checksum, or cryptographic proof that validates the spec content hasn't changed after freezing.

**Root Cause**:
`spec_frozen` is just a flag in the database. It doesn't enforce anything. An attacker can:
1. Set `spec_frozen = 1` via SQL UPDATE without validation
2. Modify `metadata` (spec content) after `spec_frozen = 1` is set
3. Reset `spec_frozen = 0`, modify spec, set back to `spec_frozen = 1`

**Solution Approach**:

#### Step 1: Database Triggers (Defense Layer 1)
```sql
-- Trigger 1: Prevent spec_frozen flag modification via direct UPDATE
CREATE TRIGGER prevent_spec_frozen_tampering
BEFORE UPDATE OF spec_frozen ON tasks
FOR EACH ROW
WHEN NEW.spec_frozen != OLD.spec_frozen
BEGIN
    -- Only allow transitions through TaskService API
    -- This trigger fires on direct SQL UPDATE attempts
    SELECT CASE
        WHEN (SELECT COUNT(*) FROM sqlite_temp_master WHERE type='table' AND name='_allow_spec_frozen_update') = 0
        THEN RAISE(ABORT, 'spec_frozen can only be modified through TaskService API')
    END;
END;

-- Trigger 2: Tie spec_frozen to spec_hash existence
CREATE TRIGGER require_hash_with_frozen_flag
BEFORE UPDATE OF spec_frozen ON tasks
FOR EACH ROW
WHEN NEW.spec_frozen = 1
BEGIN
    SELECT CASE
        WHEN NEW.spec_hash IS NULL THEN
            RAISE(ABORT, 'Cannot set spec_frozen = 1 without spec_hash')
        WHEN NEW.spec_hash = '' THEN
            RAISE(ABORT, 'spec_hash cannot be empty when spec_frozen = 1')
    END;
END;

-- Trigger 3: Prevent metadata modification when frozen
CREATE TRIGGER prevent_metadata_modification_when_frozen
BEFORE UPDATE OF metadata ON tasks
FOR EACH ROW
WHEN NEW.spec_frozen = 1 AND NEW.metadata != OLD.metadata
BEGIN
    SELECT RAISE(ABORT, 'Cannot modify metadata when spec_frozen = 1 (spec is immutable)');
END;
```

#### Step 2: Hash-Flag Coupling (Defense Layer 2)
```python
class TaskManager:
    def freeze_spec(self, task_id: str) -> str:
        """Atomically freeze spec with hash coupling"""

        # Create temporary table to allow trigger bypass (controlled context)
        self.db.execute("CREATE TEMP TABLE IF NOT EXISTS _allow_spec_frozen_update (id INTEGER)")

        try:
            task = self.get_task(task_id)
            spec = task.metadata.get("spec", {})

            # Compute hash
            spec_hash = compute_spec_hash(spec)

            # Update both atomically (within trigger bypass context)
            self.db.execute("""
                UPDATE tasks
                SET spec_frozen = 1, spec_hash = ?
                WHERE task_id = ?
            """, (spec_hash, task_id))

            # Audit
            audit_log("spec_freeze", task_id=task_id, spec_hash=spec_hash)

            return spec_hash

        finally:
            # Remove bypass context
            self.db.execute("DROP TABLE IF EXISTS _allow_spec_frozen_update")

    def verify_spec_integrity(self, task_id: str) -> bool:
        """Verify spec hasn't been tampered with"""
        task = self.get_task(task_id)

        if not task.is_spec_frozen():
            return True  # Not frozen, no integrity check needed

        if not task.spec_hash:
            raise SpecHashMissingError(f"Task {task_id} is frozen but has no hash")

        # Recompute current hash
        current_hash = compute_spec_hash(task.metadata.get("spec", {}))

        # Compare
        if current_hash != task.spec_hash:
            audit_log("spec_tampering_detected",
                     task_id=task_id,
                     expected=task.spec_hash,
                     actual=current_hash)
            return False

        return True
```

#### Step 3: Audit Trail (Defense Layer 3)
```python
def audit_spec_freeze_attempt(task_id: str, success: bool, error: str = None):
    """Log all spec freeze attempts for forensics"""
    audit_log(
        "spec_freeze_attempt",
        task_id=task_id,
        success=success,
        error=error,
        timestamp=datetime.utcnow(),
        stack_trace=traceback.format_stack() if not success else None
    )

def audit_spec_access(task_id: str, operation: str):
    """Log all spec read/write operations"""
    audit_log(
        "spec_access",
        task_id=task_id,
        operation=operation,  # "read", "write", "freeze", "verify"
        timestamp=datetime.utcnow()
    )
```

**Priority**: CRITICAL
**Target**: v0.6.1 Release Blocker

**Acceptance Criteria**:
- [ ] Database triggers prevent direct modification of `spec_frozen` flag
- [ ] `spec_frozen = 1` requires `spec_hash IS NOT NULL` (enforced by trigger)
- [ ] Metadata modification blocked when `spec_frozen = 1` (enforced by trigger)
- [ ] TaskService API is the ONLY way to set `spec_frozen = 1` (via bypass context)
- [ ] Tampering attempts logged to audit trail
- [ ] Penetration test B3-C2 bypass attempts fail
- [ ] Integration tests verify trigger enforcement
- [ ] Documentation explains trigger bypass mechanism

**References**:
- **Vulnerability Report**: `BOUNDARY_PENETRATION_TEST_REPORT.md` (Lines 582-594, B3-C2)
- **Related**: B3-C1 (same root cause, different attack vector)

**Estimated Effort**: 2-3 days
**Dependencies**: Sub-task 2 (B3-C1) - same spec_hash mechanism

---

## Technical Solution Overview

### Planning Guard System-Level Enforcement (B2-C1)

**Approach**: Import Hooks + Task Context Propagation

```python
# Architecture:
┌─────────────────────────────────────────────────────────┐
│ Application Code                                        │
│   subprocess.run(["echo", "test"])  ← Looks normal     │
└────────────────────┬────────────────────────────────────┘
                     │ (import time)
                     ▼
┌─────────────────────────────────────────────────────────┐
│ Import Hook (sys.meta_path)                             │
│   - Intercepts subprocess/os/socket imports             │
│   - Wraps side-effect functions                         │
│   - Injects planning guard checks                       │
└────────────────────┬────────────────────────────────────┘
                     │ (runtime)
                     ▼
┌─────────────────────────────────────────────────────────┐
│ Guarded Function Wrapper                                │
│   def guarded_run(*args, **kwargs):                     │
│       task_ctx = get_current_task_context()             │
│       planning_guard.assert_allowed("subprocess", ctx)  │
│       return original_run(*args, **kwargs)              │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ Planning Guard                                          │
│   - Checks task_ctx.status ∈ {DRAFT, APPROVED}?        │
│   - YES → Raise PlanningSideEffectForbiddenError        │
│   - NO  → Allow (RUNNING/VERIFYING/DONE)               │
└─────────────────────────────────────────────────────────┘
```

**Key Components**:
1. **Import Hook**: Installed at application startup, intercepts all side-effect imports
2. **Task Context**: Thread-local storage propagates current task through call stack
3. **Guarded Wrappers**: Transparent proxies that check context before delegating
4. **Planning Guard**: Existing guard logic, now automatically invoked

### Cryptographic Spec Verification (B3-C1, B3-C2)

**Approach**: SHA-256 Hash + Database Triggers + Audit Trail

```python
# Architecture:
┌─────────────────────────────────────────────────────────┐
│ TaskService.freeze_spec(task_id)                        │
│   1. Get task spec from metadata                        │
│   2. Compute SHA-256 hash (canonical JSON)              │
│   3. UPDATE spec_frozen=1, spec_hash=hash (atomic)      │
│   4. Audit log                                          │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ Database Triggers (Enforcement)                         │
│   1. Require spec_hash when spec_frozen=1               │
│   2. Prevent metadata UPDATE when spec_frozen=1         │
│   3. Prevent spec_frozen flag tampering                 │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ ExecutorEngine.execute()                                │
│   1. Check spec_frozen = 1                              │
│   2. Check spec_hash exists                             │
│   3. Recompute current hash                             │
│   4. Compare hashes                                     │
│   5. Execute if match, error if mismatch                │
└─────────────────────────────────────────────────────────┘
```

**Key Components**:
1. **spec_hash Column**: Stores SHA-256 hash of frozen spec (256-bit, hex-encoded)
2. **Hash Computation**: Canonical JSON (sorted keys) ensures deterministic hashing
3. **Database Triggers**: Three triggers enforce spec_frozen ↔ spec_hash coupling
4. **Pre-Execution Check**: Executor verifies hash before every execution
5. **Audit Trail**: All freeze/verify operations logged for forensics

---

## Dependencies and Prerequisites

### Prerequisites
- [ ] v0.6.0 release complete
- [ ] v0.6.0 friction mechanisms validated in production
- [ ] Penetration test suite from Task #8 available for regression testing

### Technical Dependencies
- [ ] Task context propagation mechanism (for import hooks)
- [ ] Database migration system (for spec_hash column)
- [ ] Audit logging system (for tampering detection)

### External Dependencies
None - All changes are internal to AgentOS

---

## Success Criteria

### Functional Requirements
- [ ] All 3 critical vulnerabilities (B2-C1, B3-C1, B3-C2) fixed
- [ ] Penetration tests re-run with 100% pass rate
- [ ] No regression in existing functionality
- [ ] No new vulnerabilities introduced

### Non-Functional Requirements
- [ ] Performance: < 5% overhead on planning operations
- [ ] Performance: < 2% overhead on execution validation
- [ ] Security: Cryptographic guarantees verified by security review
- [ ] Usability: Clear error messages for blocked operations
- [ ] Maintainability: Code complexity acceptable (no "magic")

### Documentation Requirements
- [ ] ADR updated with system-level enforcement approach
- [ ] Troubleshooting guide for import hook issues
- [ ] Migration guide for v0.6.0 → v0.6.1
- [ ] Security model documentation updated

### Testing Requirements
- [ ] All penetration tests pass (3 critical vulnerabilities)
- [ ] Unit tests for import hooks (10+ scenarios)
- [ ] Unit tests for spec hash verification (10+ scenarios)
- [ ] Integration tests for database triggers (5+ scenarios)
- [ ] E2E tests for complete workflow (3+ scenarios)
- [ ] Performance benchmarks (planning + execution)

---

## Risks and Mitigations

### Risk 1: Import Hooks Performance Overhead
**Probability**: Medium
**Impact**: High (if > 10% overhead)
**Mitigation**:
- Benchmark import hook overhead before implementation
- Use caching for task context lookups
- Only wrap high-risk modules (subprocess, os, socket)
- Add opt-out for performance-critical code paths

### Risk 2: Import Hooks Break Third-Party Libraries
**Probability**: Medium
**Impact**: High (if libraries fail to import)
**Mitigation**:
- Whitelist known-safe libraries (e.g., numpy, pandas)
- Add escape hatch to disable hooks for specific modules
- Comprehensive integration testing with common libraries
- Document known incompatibilities

### Risk 3: Database Triggers Too Restrictive
**Probability**: Low
**Impact**: Medium (if legitimate operations blocked)
**Mitigation**:
- Controlled trigger bypass mechanism for TaskService
- Clear error messages for trigger violations
- Audit trail for all trigger firings
- Rollback plan if triggers cause issues

### Risk 4: Hash Computation Performance
**Probability**: Low
**Impact**: Low (hashing is fast)
**Mitigation**:
- Use SHA-256 (proven fast and secure)
- Benchmark on large specs (>1MB)
- Add caching for repeated verifications
- Document maximum spec size recommendations

---

## Known Limitations

### Limitation 1: Import Hooks Only Work for Python Code
**Description**: Import hooks cannot intercept:
- C extension side effects
- System calls from native libraries
- Subprocess operations that bypass Python subprocess module

**Workaround**: Future v0.6.2 may add OS-level sandbox (containers)

### Limitation 2: Task Context Must Be Propagated
**Description**: Import hooks require task context in thread-local storage. If context is not propagated correctly:
- Async operations may lose context
- Multi-threaded operations need explicit propagation
- Third-party thread pools need instrumentation

**Workaround**: Documentation clearly explains context propagation requirements

### Limitation 3: Database Triggers Require SQLite 3.8+
**Description**: The trigger syntax used requires SQLite 3.8.0 or later.

**Workaround**: Minimum SQLite version check at startup, clear error if too old

---

## Version Dependencies

```
v0.6.0 (Convention + Friction)
   ↓
v0.6.1 (System-Level Enforcement)
   ↓
v0.6.2 (OS-Level Sandbox) [Future]
```

**Blocks**: None
**Blocked By**: v0.6.0 production validation

---

## Rollback Plan

If v0.6.1 causes critical issues in production:

1. **Disable Import Hooks**: Environment variable `AGENTOS_DISABLE_IMPORT_HOOKS=1`
2. **Disable Triggers**: SQL migration to drop triggers (keep spec_hash column)
3. **Revert to v0.6.0**: Full rollback via git tag + database migration

**Rollback Criteria**:
- Performance regression > 10%
- Import hooks break critical third-party libraries
- Database triggers block legitimate operations
- Security issues discovered in new enforcement

---

## Timeline and Effort Estimate

### Phase 1: Design and Prototyping (5 days)
- [ ] Import hook prototype
- [ ] Hash verification prototype
- [ ] Performance benchmarking
- [ ] Security review of approach

### Phase 2: Implementation (10 days)
- [ ] Sub-task 1: Import hooks (5 days)
- [ ] Sub-task 2: Spec hash (3 days)
- [ ] Sub-task 3: Database triggers (2 days)

### Phase 3: Testing and Validation (7 days)
- [ ] Unit tests (3 days)
- [ ] Integration tests (2 days)
- [ ] Penetration test re-run (1 day)
- [ ] Performance validation (1 day)

### Phase 4: Documentation and Release (3 days)
- [ ] ADR updates (1 day)
- [ ] Migration guide (1 day)
- [ ] Release notes (1 day)

**Total Estimated Effort**: 25 days (~5 weeks)

---

## References

### Vulnerability Documentation
- **BOUNDARY_PENETRATION_TEST_REPORT.md**: Complete penetration test results with 3 critical vulnerabilities
  - B2-C1: Lines 208-307
  - B3-C1: Lines 455-579
  - B3-C2: Lines 582-594

### Architecture Documentation
- **ADR_EXECUTION_BOUNDARIES_FREEZE.md**: Known Limitations section (references these vulnerabilities)
- **V04_CONSTRAINTS_AND_GATES.md**: Current state machine constraints

### Current Implementation
- **agentos/core/task/planning_guard.py**: Current planning guard (convention-based)
- **agentos/core/executor/executor_engine.py**: Current spec_frozen check (flag-based)
- **agentos/store/migrations/schema_v31_project_aware.sql**: Current database schema

### Testing
- **tests/boundary/test_penetration_planning_side_effects.py**: B2-C1 attack vectors
- **tests/boundary/test_penetration_frozen_spec.py**: B3-C1, B3-C2 attack vectors

---

## Appendix: Design Alternatives Considered

### Alternative 1: sys.settrace() Instead of Import Hooks
**Rejected**: Too much performance overhead (traces every call)

### Alternative 2: Static Analysis Only
**Rejected**: Cannot catch runtime bypasses, only linting value

### Alternative 3: OS-Level Sandbox (Containers)
**Deferred**: Too much infrastructure complexity for v0.6.1, consider for v0.6.2

### Alternative 4: Blockchain-Style Hash Chain
**Rejected**: Overkill for single-task immutability, SHA-256 sufficient

---

**Epic Owner**: AgentOS Security Team
**Target Reviewers**: Architecture Team, Security Team
**Status**: PLANNED - Awaiting v0.6.0 production validation
**Next Review**: Post v0.6.0 release + 2 weeks production telemetry

---

**Document Version**: v1.0
**Last Updated**: 2026-01-30
**Changelog**:
- 2026-01-30: Initial epic creation (Task #11)
